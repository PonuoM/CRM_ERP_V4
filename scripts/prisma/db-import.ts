#!/usr/bin/env node

/**
 * Import data from prisma/data.sql into the current database.
 *
 * WARNING: This script will DELETE ALL DATA from all tables
 * defined in prisma/schema.prisma before importing.
 */

import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";
import { PrismaClient } from "@prisma/client";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const schemaPath = path.resolve(__dirname, "../../prisma/schema.prisma");
  const dataPath = path.resolve(__dirname, "../../prisma/data.sql");

  console.log(`[db:import] Reading Prisma schema from: ${schemaPath}`);
  console.log(`[db:import] Reading data from: ${dataPath}`);

  const sql = await fs.readFile(dataPath, "utf8");
  if (!sql.trim()) {
    throw new Error("prisma/data.sql is empty, nothing to import");
  }

  const prisma = new PrismaClient();

  try {
    // Get list of mapped models/tables from schema
    const schema = await fs.readFile(schemaPath, "utf8");
    const modelRegex = /model\s+(\w+)\s+\{([\s\S]*?)\}/g;

    const tables: string[] = [];

    let m: RegExpExecArray | null;
    while ((m = modelRegex.exec(schema)) !== null) {
      const [, modelName, body] = m;
      const lines = body.split("\n").map((l) => l.trim());

      let dbName: string | null = null;
      for (const line of lines) {
        if (line.startsWith("@@map(")) {
          const mm = line.match(/^@@map\("([^"]+)"\)/);
          if (mm) {
            dbName = mm[1];
            break;
          }
        }
      }

      tables.push(dbName ?? modelName);
    }

    if (!tables.length) {
      throw new Error("No models/tables found in schema.prisma");
    }

    console.log(
      "[db:import] WARNING: truncating all tables before import:\n  " +
        tables.join(", "),
    );

    // Disable foreign key checks globally and for this session, then truncate/import.
    // (Prisma may use a connection pool, so we use GLOBAL to ensure all
    // connections see FOREIGN_KEY_CHECKS = 0 during the import.)
    try {
      await prisma.$executeRawUnsafe("SET GLOBAL FOREIGN_KEY_CHECKS=0;");
    } catch {
      // Ignore if we don't have permission; we'll still try session-level
    }
    await prisma.$executeRawUnsafe("SET FOREIGN_KEY_CHECKS=0;");

    for (const table of tables) {
      console.log(`[db:import] Truncating table: ${table}`);
      await prisma.$executeRawUnsafe(`TRUNCATE TABLE \`${table}\`;`);
      // Explicitly reset AUTO_INCREMENT to 1 (TRUNCATE normally does this,
      // but we force it here to be sure, and to cover engines/settings where
      // TRUNCATE does not reset as expected).
      await prisma.$executeRawUnsafe(
        `ALTER TABLE \`${table}\` AUTO_INCREMENT = 1;`,
      );
    }

    console.log("[db:import] Running SQL from data.sql...");

    // Remove full-line comments first, then split into individual statements.
    const cleanedSql = sql
      .split(/\r?\n/g)
      .filter((line) => !line.trim().startsWith("--"))
      .join("\n");

    // Split into individual statements by semicolon. Handle both LF and CRLF.
    // data.sql is generated by our exporter so it is safe to split on ';' at line ends.
    const statements = cleanedSql
      .split(/;\s*[\r\n]+/g)
      .map((s) => s.trim())
      .filter((s) => s.length);

    for (const stmt of statements) {
      try {
        await prisma.$executeRawUnsafe(stmt);
      } catch (err: any) {
        // If a statement fails because of duplicate key (MySQL code 1062),
        // skip it so the rest of the import can continue.
        const code = err?.meta?.code ?? err?.code;
        if (code === "1062") {
          console.warn(
            "[db:import] Skipping duplicate key statement:",
            stmt.slice(0, 160),
          );
          continue;
        }
        throw err;
      }
    }

    try {
      await prisma.$executeRawUnsafe("SET GLOBAL FOREIGN_KEY_CHECKS=1;");
    } catch {
      // Ignore if we don't have permission
    }
    await prisma.$executeRawUnsafe("SET FOREIGN_KEY_CHECKS=1;");

    console.log("[db:import] Import completed successfully.");
  } finally {
    await prisma.$disconnect();
  }
}

main().catch((err) => {
  console.error("[db:import] Failed to import data:", err);
  process.exit(1);
});
